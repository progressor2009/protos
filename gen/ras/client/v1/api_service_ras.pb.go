// Code generated by protoc-gen-go-ras. DO NOT EDIT.

// This is a compile-time assertion to ensure that this generated file
// is compatible with the v8platform/protoc-gen-go-ras ras it is being compiled against.

package clientv1

import (
	context "context"
	v1 "github.com/v8platform/protos/gen/ras/messages/v1"
	v11 "github.com/v8platform/protos/gen/ras/protocol/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

type ClustersService interface {
	GetClusters(ctx context.Context, req *v1.GetClustersRequest, opts ...interface{}) (*v1.GetClustersResponse, error)
	GetClusterInfo(ctx context.Context, req *v1.GetClusterInfoRequest, opts ...interface{}) (*v1.GetClusterInfoResponse, error)
	RegCluster(ctx context.Context, req *v1.RegClusterRequest, opts ...interface{}) (*v1.RegClusterResponse, error)
	UnregCluster(ctx context.Context, req *v1.UnregClusterRequest, opts ...interface{}) (*emptypb.Empty, error)
	GetManagers(ctx context.Context, req *v1.GetClusterManagersRequest, opts ...interface{}) (*v1.GetClusterManagersResponse, error)
	GetManagerInfo(ctx context.Context, req *v1.GetClusterManagerInfoRequest, opts ...interface{}) (*v1.GetClusterManagerInfoResponse, error)
	GetWorkingProcesses(ctx context.Context, req *v1.GetWorkingProcessesRequest, opts ...interface{}) (*v1.GetWorkingProcessesResponse, error)
	GetWorkingProcessInfo(ctx context.Context, req *v1.GetWorkingProcessInfoRequest, opts ...interface{}) (*v1.GetWorkingProcessInfoResponse, error)
	GetWorkingServers(ctx context.Context, req *v1.GetWorkingServersRequest, opts ...interface{}) (*v1.GetWorkingServersResponse, error)
	GetWorkingServerInfo(ctx context.Context, req *v1.GetWorkingServerInfoRequest, opts ...interface{}) (*v1.GetWorkingServerInfoResponse, error)
	AddWorkingServer(ctx context.Context, req *v1.AddWorkingServerRequest, opts ...interface{}) (*v1.AddWorkingServerResponse, error)
	DeleteWorkingServer(ctx context.Context, req *v1.DeleteWorkingServerRequest, opts ...interface{}) (*emptypb.Empty, error)
}

func NewClustersService(client Client) ClustersService {
	return &clustersService{
		client,
	}
}

// ClustersService is the endpoint message service for RAS service.
type clustersService struct {
	cc Client
}

func (x *clustersService) GetClusters(ctx context.Context, req *v1.GetClustersRequest, opts ...interface{}) (*v1.GetClustersResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetClustersHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetClustersResponse), nil
}

func GetClustersHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetClustersResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetClustersRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetClusters",
		FullMethod: "/ras.client.v1.ClustersService/GetClusters",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetClustersResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetClustersRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) GetClusterInfo(ctx context.Context, req *v1.GetClusterInfoRequest, opts ...interface{}) (*v1.GetClusterInfoResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetClusterInfoHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetClusterInfoResponse), nil
}

func GetClusterInfoHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetClusterInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetClusterInfoRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetClusterInfo",
		FullMethod: "/ras.client.v1.ClustersService/GetClusterInfo",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetClusterInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetClusterInfoRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) RegCluster(ctx context.Context, req *v1.RegClusterRequest, opts ...interface{}) (*v1.RegClusterResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, RegClusterHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.RegClusterResponse), nil
}

func RegClusterHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.RegClusterResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.RegClusterRequest), reply)
	}
	info := &RequestInfo{
		Method:     "RegCluster",
		FullMethod: "/ras.client.v1.ClustersService/RegCluster",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.RegClusterResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.RegClusterRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) UnregCluster(ctx context.Context, req *v1.UnregClusterRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, UnregClusterHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func UnregClusterHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.UnregClusterRequest), nil)
	}
	info := &RequestInfo{
		Method:     "UnregCluster",
		FullMethod: "/ras.client.v1.ClustersService/UnregCluster",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.UnregClusterRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) GetManagers(ctx context.Context, req *v1.GetClusterManagersRequest, opts ...interface{}) (*v1.GetClusterManagersResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetManagersHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetClusterManagersResponse), nil
}

func GetManagersHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetClusterManagersResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetClusterManagersRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetManagers",
		FullMethod: "/ras.client.v1.ClustersService/GetManagers",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetClusterManagersResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetClusterManagersRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) GetManagerInfo(ctx context.Context, req *v1.GetClusterManagerInfoRequest, opts ...interface{}) (*v1.GetClusterManagerInfoResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetManagerInfoHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetClusterManagerInfoResponse), nil
}

func GetManagerInfoHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetClusterManagerInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetClusterManagerInfoRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetManagerInfo",
		FullMethod: "/ras.client.v1.ClustersService/GetManagerInfo",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetClusterManagerInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetClusterManagerInfoRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) GetWorkingProcesses(ctx context.Context, req *v1.GetWorkingProcessesRequest, opts ...interface{}) (*v1.GetWorkingProcessesResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetWorkingProcessesHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetWorkingProcessesResponse), nil
}

func GetWorkingProcessesHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetWorkingProcessesResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetWorkingProcessesRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetWorkingProcesses",
		FullMethod: "/ras.client.v1.ClustersService/GetWorkingProcesses",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetWorkingProcessesResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetWorkingProcessesRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) GetWorkingProcessInfo(ctx context.Context, req *v1.GetWorkingProcessInfoRequest, opts ...interface{}) (*v1.GetWorkingProcessInfoResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetWorkingProcessInfoHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetWorkingProcessInfoResponse), nil
}

func GetWorkingProcessInfoHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetWorkingProcessInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetWorkingProcessInfoRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetWorkingProcessInfo",
		FullMethod: "/ras.client.v1.ClustersService/GetWorkingProcessInfo",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetWorkingProcessInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetWorkingProcessInfoRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) GetWorkingServers(ctx context.Context, req *v1.GetWorkingServersRequest, opts ...interface{}) (*v1.GetWorkingServersResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetWorkingServersHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetWorkingServersResponse), nil
}

func GetWorkingServersHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetWorkingServersResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetWorkingServersRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetWorkingServers",
		FullMethod: "/ras.client.v1.ClustersService/GetWorkingServers",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetWorkingServersResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetWorkingServersRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) GetWorkingServerInfo(ctx context.Context, req *v1.GetWorkingServerInfoRequest, opts ...interface{}) (*v1.GetWorkingServerInfoResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetWorkingServerInfoHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetWorkingServerInfoResponse), nil
}

func GetWorkingServerInfoHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetWorkingServerInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetWorkingServerInfoRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetWorkingServerInfo",
		FullMethod: "/ras.client.v1.ClustersService/GetWorkingServerInfo",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetWorkingServerInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetWorkingServerInfoRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) AddWorkingServer(ctx context.Context, req *v1.AddWorkingServerRequest, opts ...interface{}) (*v1.AddWorkingServerResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, AddWorkingServerHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.AddWorkingServerResponse), nil
}

func AddWorkingServerHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.AddWorkingServerResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.AddWorkingServerRequest), reply)
	}
	info := &RequestInfo{
		Method:     "AddWorkingServer",
		FullMethod: "/ras.client.v1.ClustersService/AddWorkingServer",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.AddWorkingServerResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.AddWorkingServerRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *clustersService) DeleteWorkingServer(ctx context.Context, req *v1.DeleteWorkingServerRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, DeleteWorkingServerHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func DeleteWorkingServerHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.DeleteWorkingServerRequest), nil)
	}
	info := &RequestInfo{
		Method:     "DeleteWorkingServer",
		FullMethod: "/ras.client.v1.ClustersService/DeleteWorkingServer",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.DeleteWorkingServerRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

type InfobasesService interface {
	GetInfobasesSummary(ctx context.Context, req *v1.GetInfobasesSummaryRequest, opts ...interface{}) (*v1.GetInfobasesSummaryResponse, error)
	GetInfobases(ctx context.Context, req *v1.GetInfobasesRequest, opts ...interface{}) (*v1.GetInfobasesResponse, error)
	GetInfobase(ctx context.Context, req *v1.GetInfobaseInfoRequest, opts ...interface{}) (*v1.GetInfobaseInfoResponse, error)
	CreateInfobase(ctx context.Context, req *v1.CreateInfobaseRequest, opts ...interface{}) (*v1.CreateInfobaseResponse, error)
	DropInfobase(ctx context.Context, req *v1.DropInfobaseRequest, opts ...interface{}) (*emptypb.Empty, error)
	UpdateInfobase(ctx context.Context, req *v1.UpdateInfobaseRequest, opts ...interface{}) (*emptypb.Empty, error)
	UpdateInfobaseSummary(ctx context.Context, req *v1.UpdateInfobaseSummaryRequest, opts ...interface{}) (*emptypb.Empty, error)
}

func NewInfobasesService(client Client) InfobasesService {
	return &infobasesService{
		client,
	}
}

// InfobasesService is the endpoint message service for RAS service.
type infobasesService struct {
	cc Client
}

func (x *infobasesService) GetInfobasesSummary(ctx context.Context, req *v1.GetInfobasesSummaryRequest, opts ...interface{}) (*v1.GetInfobasesSummaryResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetInfobasesSummaryHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetInfobasesSummaryResponse), nil
}

func GetInfobasesSummaryHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetInfobasesSummaryResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetInfobasesSummaryRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetInfobasesSummary",
		FullMethod: "/ras.client.v1.InfobasesService/GetInfobasesSummary",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetInfobasesSummaryResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetInfobasesSummaryRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *infobasesService) GetInfobases(ctx context.Context, req *v1.GetInfobasesRequest, opts ...interface{}) (*v1.GetInfobasesResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetInfobasesHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetInfobasesResponse), nil
}

func GetInfobasesHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetInfobasesResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetInfobasesRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetInfobases",
		FullMethod: "/ras.client.v1.InfobasesService/GetInfobases",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetInfobasesResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetInfobasesRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *infobasesService) GetInfobase(ctx context.Context, req *v1.GetInfobaseInfoRequest, opts ...interface{}) (*v1.GetInfobaseInfoResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetInfobaseHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetInfobaseInfoResponse), nil
}

func GetInfobaseHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetInfobaseInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetInfobaseInfoRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetInfobase",
		FullMethod: "/ras.client.v1.InfobasesService/GetInfobase",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetInfobaseInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetInfobaseInfoRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *infobasesService) CreateInfobase(ctx context.Context, req *v1.CreateInfobaseRequest, opts ...interface{}) (*v1.CreateInfobaseResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, CreateInfobaseHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.CreateInfobaseResponse), nil
}

func CreateInfobaseHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.CreateInfobaseResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.CreateInfobaseRequest), reply)
	}
	info := &RequestInfo{
		Method:     "CreateInfobase",
		FullMethod: "/ras.client.v1.InfobasesService/CreateInfobase",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.CreateInfobaseResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.CreateInfobaseRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *infobasesService) DropInfobase(ctx context.Context, req *v1.DropInfobaseRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, DropInfobaseHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func DropInfobaseHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.DropInfobaseRequest), nil)
	}
	info := &RequestInfo{
		Method:     "DropInfobase",
		FullMethod: "/ras.client.v1.InfobasesService/DropInfobase",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.DropInfobaseRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *infobasesService) UpdateInfobase(ctx context.Context, req *v1.UpdateInfobaseRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, UpdateInfobaseHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func UpdateInfobaseHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.UpdateInfobaseRequest), nil)
	}
	info := &RequestInfo{
		Method:     "UpdateInfobase",
		FullMethod: "/ras.client.v1.InfobasesService/UpdateInfobase",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.UpdateInfobaseRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *infobasesService) UpdateInfobaseSummary(ctx context.Context, req *v1.UpdateInfobaseSummaryRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, UpdateInfobaseSummaryHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func UpdateInfobaseSummaryHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.UpdateInfobaseSummaryRequest), nil)
	}
	info := &RequestInfo{
		Method:     "UpdateInfobaseSummary",
		FullMethod: "/ras.client.v1.InfobasesService/UpdateInfobaseSummary",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.UpdateInfobaseSummaryRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

type SessionsService interface {
	GetSessions(ctx context.Context, req *v1.GetSessionsRequest, opts ...interface{}) (*v1.GetSessionsResponse, error)
	GetInfobaseSessions(ctx context.Context, req *v1.GetInfobaseSessionsRequest, opts ...interface{}) (*v1.GetInfobaseSessionsResponse, error)
	GetSessionInfo(ctx context.Context, req *v1.GetSessionInfoRequest, opts ...interface{}) (*v1.GetSessionInfoResponse, error)
	TerminateSession(ctx context.Context, req *v1.TerminateSessionRequest, opts ...interface{}) (*emptypb.Empty, error)
}

func NewSessionsService(client Client) SessionsService {
	return &sessionsService{
		client,
	}
}

// SessionsService is the endpoint message service for RAS service.
type sessionsService struct {
	cc Client
}

func (x *sessionsService) GetSessions(ctx context.Context, req *v1.GetSessionsRequest, opts ...interface{}) (*v1.GetSessionsResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetSessionsHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetSessionsResponse), nil
}

func GetSessionsHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetSessionsResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetSessionsRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetSessions",
		FullMethod: "/ras.client.v1.SessionsService/GetSessions",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetSessionsResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetSessionsRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *sessionsService) GetInfobaseSessions(ctx context.Context, req *v1.GetInfobaseSessionsRequest, opts ...interface{}) (*v1.GetInfobaseSessionsResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetInfobaseSessionsHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetInfobaseSessionsResponse), nil
}

func GetInfobaseSessionsHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetInfobaseSessionsResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetInfobaseSessionsRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetInfobaseSessions",
		FullMethod: "/ras.client.v1.SessionsService/GetInfobaseSessions",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetInfobaseSessionsResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetInfobaseSessionsRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *sessionsService) GetSessionInfo(ctx context.Context, req *v1.GetSessionInfoRequest, opts ...interface{}) (*v1.GetSessionInfoResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetSessionInfoHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetSessionInfoResponse), nil
}

func GetSessionInfoHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetSessionInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetSessionInfoRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetSessionInfo",
		FullMethod: "/ras.client.v1.SessionsService/GetSessionInfo",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetSessionInfoResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetSessionInfoRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *sessionsService) TerminateSession(ctx context.Context, req *v1.TerminateSessionRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, TerminateSessionHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func TerminateSessionHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.TerminateSessionRequest), nil)
	}
	info := &RequestInfo{
		Method:     "TerminateSession",
		FullMethod: "/ras.client.v1.SessionsService/TerminateSession",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.TerminateSessionRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

type LocksService interface {
	GetLocks(ctx context.Context, req *v1.GetLocksRequest, opts ...interface{}) (*v1.GetLocksResponse, error)
	GetInfobaseLocks(ctx context.Context, req *v1.GetInfobaseLocksRequest, opts ...interface{}) (*v1.GetInfobaseLocksResponse, error)
	GetConnectionLocks(ctx context.Context, req *v1.GetConnectionLocksRequest, opts ...interface{}) (*v1.GetConnectionLocksResponse, error)
	GetSessionLocks(ctx context.Context, req *v1.GetSessionLocksRequest, opts ...interface{}) (*v1.GetSessionLocksResponse, error)
}

func NewLocksService(client Client) LocksService {
	return &locksService{
		client,
	}
}

// LocksService is the endpoint message service for RAS service.
type locksService struct {
	cc Client
}

func (x *locksService) GetLocks(ctx context.Context, req *v1.GetLocksRequest, opts ...interface{}) (*v1.GetLocksResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetLocksHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetLocksResponse), nil
}

func GetLocksHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetLocksResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetLocksRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetLocks",
		FullMethod: "/ras.client.v1.LocksService/GetLocks",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetLocksResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetLocksRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *locksService) GetInfobaseLocks(ctx context.Context, req *v1.GetInfobaseLocksRequest, opts ...interface{}) (*v1.GetInfobaseLocksResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetInfobaseLocksHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetInfobaseLocksResponse), nil
}

func GetInfobaseLocksHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetInfobaseLocksResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetInfobaseLocksRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetInfobaseLocks",
		FullMethod: "/ras.client.v1.LocksService/GetInfobaseLocks",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetInfobaseLocksResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetInfobaseLocksRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *locksService) GetConnectionLocks(ctx context.Context, req *v1.GetConnectionLocksRequest, opts ...interface{}) (*v1.GetConnectionLocksResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetConnectionLocksHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetConnectionLocksResponse), nil
}

func GetConnectionLocksHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetConnectionLocksResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetConnectionLocksRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetConnectionLocks",
		FullMethod: "/ras.client.v1.LocksService/GetConnectionLocks",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetConnectionLocksResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetConnectionLocksRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *locksService) GetSessionLocks(ctx context.Context, req *v1.GetSessionLocksRequest, opts ...interface{}) (*v1.GetSessionLocksResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetSessionLocksHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetSessionLocksResponse), nil
}

func GetSessionLocksHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetSessionLocksResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetSessionLocksRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetSessionLocks",
		FullMethod: "/ras.client.v1.LocksService/GetSessionLocks",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetSessionLocksResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetSessionLocksRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

type ConnectionsService interface {
	GetConnections(ctx context.Context, req *v1.GetConnectionsRequest, opts ...interface{}) (*v1.GetConnectionsResponse, error)
	GetInfobaseConnections(ctx context.Context, req *v1.GetInfobaseConnectionsRequest, opts ...interface{}) (*v1.GetInfobaseConnectionsResponse, error)
	DisconnectConnection(ctx context.Context, req *v1.DisconnectConnectionRequest, opts ...interface{}) (*emptypb.Empty, error)
}

func NewConnectionsService(client Client) ConnectionsService {
	return &connectionsService{
		client,
	}
}

// ConnectionsService is the endpoint message service for RAS service.
type connectionsService struct {
	cc Client
}

func (x *connectionsService) GetConnections(ctx context.Context, req *v1.GetConnectionsRequest, opts ...interface{}) (*v1.GetConnectionsResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetConnectionsHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetConnectionsResponse), nil
}

func GetConnectionsHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetConnectionsResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetConnectionsRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetConnections",
		FullMethod: "/ras.client.v1.ConnectionsService/GetConnections",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetConnectionsResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetConnectionsRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *connectionsService) GetInfobaseConnections(ctx context.Context, req *v1.GetInfobaseConnectionsRequest, opts ...interface{}) (*v1.GetInfobaseConnectionsResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetInfobaseConnectionsHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetInfobaseConnectionsResponse), nil
}

func GetInfobaseConnectionsHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetInfobaseConnectionsResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetInfobaseConnectionsRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetInfobaseConnections",
		FullMethod: "/ras.client.v1.ConnectionsService/GetInfobaseConnections",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetInfobaseConnectionsResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetInfobaseConnectionsRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *connectionsService) DisconnectConnection(ctx context.Context, req *v1.DisconnectConnectionRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, DisconnectConnectionHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func DisconnectConnectionHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.DisconnectConnectionRequest), nil)
	}
	info := &RequestInfo{
		Method:     "DisconnectConnection",
		FullMethod: "/ras.client.v1.ConnectionsService/DisconnectConnection",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.DisconnectConnectionRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

type AuthService interface {
	AuthenticateCluster(ctx context.Context, req *v1.ClusterAuthenticateRequest, opts ...interface{}) (*emptypb.Empty, error)
	AuthenticateInfobase(ctx context.Context, req *v1.AuthenticateInfobaseRequest, opts ...interface{}) (*emptypb.Empty, error)
	AuthenticateServer(ctx context.Context, req *v1.ServerAuthenticateRequest, opts ...interface{}) (*emptypb.Empty, error)
}

func NewAuthService(client Client) AuthService {
	return &authService{
		client,
	}
}

// AuthService is the endpoint message service for RAS service.
type authService struct {
	cc Client
}

func (x *authService) AuthenticateCluster(ctx context.Context, req *v1.ClusterAuthenticateRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, AuthenticateClusterHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func AuthenticateClusterHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.ClusterAuthenticateRequest), nil)
	}
	info := &RequestInfo{
		Method:     "AuthenticateCluster",
		FullMethod: "/ras.client.v1.AuthService/AuthenticateCluster",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.ClusterAuthenticateRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *authService) AuthenticateInfobase(ctx context.Context, req *v1.AuthenticateInfobaseRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, AuthenticateInfobaseHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func AuthenticateInfobaseHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.AuthenticateInfobaseRequest), nil)
	}
	info := &RequestInfo{
		Method:     "AuthenticateInfobase",
		FullMethod: "/ras.client.v1.AuthService/AuthenticateInfobase",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.AuthenticateInfobaseRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *authService) AuthenticateServer(ctx context.Context, req *v1.ServerAuthenticateRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, AuthenticateServerHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func AuthenticateServerHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.ServerAuthenticateRequest), nil)
	}
	info := &RequestInfo{
		Method:     "AuthenticateServer",
		FullMethod: "/ras.client.v1.AuthService/AuthenticateServer",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.ServerAuthenticateRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

type AdminService interface {
	GetVersion(ctx context.Context, req *v1.GetAgentVersionRequest, opts ...interface{}) (*v1.GetAgentVersionResponse, error)
	GetServerAdmins(ctx context.Context, req *v1.GetAgentAdminsRequest, opts ...interface{}) (*v1.GetAgentAdminsResponse, error)
	GetClustersAdmins(ctx context.Context, req *v1.GetClusterAdminsRequest, opts ...interface{}) (*v1.GetClusterAdminsResponse, error)
	CreateServerAdmin(ctx context.Context, req *v1.CreateAgentAdminRequest, opts ...interface{}) (*emptypb.Empty, error)
	CreateClusterAdmin(ctx context.Context, req *v1.CreateClusterAdminRequest, opts ...interface{}) (*emptypb.Empty, error)
	DeleteServerAdmin(ctx context.Context, req *v1.DeleteAgentAdminRequest, opts ...interface{}) (*emptypb.Empty, error)
	DeleteClusterAdmin(ctx context.Context, req *v1.DeleteClusterAdminRequest, opts ...interface{}) (*emptypb.Empty, error)
}

func NewAdminService(client Client) AdminService {
	return &adminService{
		client,
	}
}

// AdminService is the endpoint message service for RAS service.
type adminService struct {
	cc Client
}

func (x *adminService) GetVersion(ctx context.Context, req *v1.GetAgentVersionRequest, opts ...interface{}) (*v1.GetAgentVersionResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetVersionHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetAgentVersionResponse), nil
}

func GetVersionHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetAgentVersionResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetAgentVersionRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetVersion",
		FullMethod: "/ras.client.v1.AdminService/GetVersion",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetAgentVersionResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetAgentVersionRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *adminService) GetServerAdmins(ctx context.Context, req *v1.GetAgentAdminsRequest, opts ...interface{}) (*v1.GetAgentAdminsResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetServerAdminsHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetAgentAdminsResponse), nil
}

func GetServerAdminsHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetAgentAdminsResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetAgentAdminsRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetServerAdmins",
		FullMethod: "/ras.client.v1.AdminService/GetServerAdmins",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetAgentAdminsResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetAgentAdminsRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *adminService) GetClustersAdmins(ctx context.Context, req *v1.GetClusterAdminsRequest, opts ...interface{}) (*v1.GetClusterAdminsResponse, error) {

	reply, err := x.cc.Invoke(ctx, true, req, GetClustersAdminsHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.GetClusterAdminsResponse), nil
}

func GetClustersAdminsHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.GetClusterAdminsResponse)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.GetClusterAdminsRequest), reply)
	}
	info := &RequestInfo{
		Method:     "GetClustersAdmins",
		FullMethod: "/ras.client.v1.AdminService/GetClustersAdmins",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.GetClusterAdminsResponse)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.GetClusterAdminsRequest), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *adminService) CreateServerAdmin(ctx context.Context, req *v1.CreateAgentAdminRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, CreateServerAdminHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func CreateServerAdminHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.CreateAgentAdminRequest), nil)
	}
	info := &RequestInfo{
		Method:     "CreateServerAdmin",
		FullMethod: "/ras.client.v1.AdminService/CreateServerAdmin",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.CreateAgentAdminRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *adminService) CreateClusterAdmin(ctx context.Context, req *v1.CreateClusterAdminRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, CreateClusterAdminHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func CreateClusterAdminHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.CreateClusterAdminRequest), nil)
	}
	info := &RequestInfo{
		Method:     "CreateClusterAdmin",
		FullMethod: "/ras.client.v1.AdminService/CreateClusterAdmin",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.CreateClusterAdminRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *adminService) DeleteServerAdmin(ctx context.Context, req *v1.DeleteAgentAdminRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, DeleteServerAdminHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func DeleteServerAdminHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.DeleteAgentAdminRequest), nil)
	}
	info := &RequestInfo{
		Method:     "DeleteServerAdmin",
		FullMethod: "/ras.client.v1.AdminService/DeleteServerAdmin",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.DeleteAgentAdminRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x *adminService) DeleteClusterAdmin(ctx context.Context, req *v1.DeleteClusterAdminRequest, opts ...interface{}) (*emptypb.Empty, error) {

	reply, err := x.cc.Invoke(ctx, true, req, DeleteClusterAdminHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func DeleteClusterAdminHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, channel, endpoint, req.(*v1.DeleteClusterAdminRequest), nil)
	}
	info := &RequestInfo{
		Method:     "DeleteClusterAdmin",
		FullMethod: "/ras.client.v1.AdminService/DeleteClusterAdmin",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v11.EndpointChannelRequest(ctx, cc, endpoint, req.(*v1.DeleteClusterAdminRequest), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}
