// Code generated by protoc-gen-go-ras. DO NOT EDIT.

// This is a compile-time assertion to ensure that this generated file
// is compatible with the v8platform/protoc-gen-go-ras ras it is being compiled against.

package clientv1

import (
	context "context"
	v1 "github.com/v8platform/protos/gen/ras/protocol/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	regexp "regexp"
	strings "strings"
)

type ClientService interface {
	Negotiate(ctx context.Context, req *v1.NegotiateMessage, opts ...interface{}) (*emptypb.Empty, error)
	Connect(ctx context.Context, req *v1.ConnectMessage, opts ...interface{}) (*v1.ConnectMessageAck, error)
	Disconnect(ctx context.Context, req *v1.DisconnectMessage, opts ...interface{}) (*emptypb.Empty, error)
	EndpointOpen(ctx context.Context, req *v1.EndpointOpen, opts ...interface{}) (*v1.EndpointOpenAck, error)
	EndpointClose(ctx context.Context, req *v1.EndpointClose, opts ...interface{}) (*emptypb.Empty, error)
	EndpointMessage(ctx context.Context, req *v1.EndpointMessage, opts ...interface{}) (*v1.EndpointMessage, error)
}

type Request func(ctx context.Context, handler RequestHandler, opts ...interface{}) error

type RequestHandler func(ctx context.Context, rw io.ReadWriter) error

type Client interface {
	Request(ctx context.Context, handler RequestHandler, opts ...interface{}) error
	GetEndpoint(ctx context.Context) (Endpoint, error)
}

type Endpoint interface {
	GetVersion() int32
	GetId() int32
}

func NewClientService(client Client) ClientService {
	return clientService{
		cc: client,
	}
}

// ClientService is the client for RAS service.
type clientService struct {
	cc Client
}

var serviceVersions = []string{"3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "9.0", "10.0"}

var re = regexp.MustCompile(`(?m)supported=(.*?)]`)

// DetectSupportedVersion func helpers detect supported version in EndpointFailureAck
func DetectSupportedVersion(err error) string {

	fail, ok := err.(*v1.EndpointFailureAck)
	if !ok {
		return ""
	}

	if fail.Cause == nil {
		return ""
	}

	matches := re.FindAllString(fail.Cause.Message, -1)

	if len(matches) == 0 {
		return ""
	}

	supported := matches[0]
	for i := len(serviceVersions) - 1; i >= 0; i-- {
		version := serviceVersions[i]
		if strings.Contains(supported, version) {
			return version
		}
	}

	return ""
}

func (x clientService) Negotiate(ctx context.Context, req *v1.NegotiateMessage, opts ...interface{}) (*emptypb.Empty, error) {
	return NegotiateHandler(ctx, x.cc.Request, req, opts...)
}

func NegotiateHandler(ctx context.Context, cc Request, req *v1.NegotiateMessage, opts ...interface{}) (*emptypb.Empty, error) {

	resp := new(emptypb.Empty)
	if err := cc(ctx, v1.PacketRequestHandler(req, nil), opts...); err != nil {
		return nil, err
	}
	return resp, nil
}

func (x clientService) Connect(ctx context.Context, req *v1.ConnectMessage, opts ...interface{}) (*v1.ConnectMessageAck, error) {
	return ConnectHandler(ctx, x.cc.Request, req, opts...)
}

func ConnectHandler(ctx context.Context, cc Request, req *v1.ConnectMessage, opts ...interface{}) (*v1.ConnectMessageAck, error) {

	resp := new(v1.ConnectMessageAck)
	if err := cc(ctx, v1.PacketRequestHandler(req, resp), opts...); err != nil {
		return nil, err
	}
	return resp, nil
}

func (x clientService) Disconnect(ctx context.Context, req *v1.DisconnectMessage, opts ...interface{}) (*emptypb.Empty, error) {
	return DisconnectHandler(ctx, x.cc.Request, req, opts...)
}

func DisconnectHandler(ctx context.Context, cc Request, req *v1.DisconnectMessage, opts ...interface{}) (*emptypb.Empty, error) {

	resp := new(emptypb.Empty)
	if err := cc(ctx, v1.PacketRequestHandler(req, nil), opts...); err != nil {
		return nil, err
	}
	return resp, nil
}

func (x clientService) EndpointOpen(ctx context.Context, req *v1.EndpointOpen, opts ...interface{}) (*v1.EndpointOpenAck, error) {
	return EndpointOpenHandler(ctx, x.cc.Request, req, opts...)
}

func EndpointOpenHandler(ctx context.Context, cc Request, req *v1.EndpointOpen, opts ...interface{}) (*v1.EndpointOpenAck, error) {

	resp := new(v1.EndpointOpenAck)
	if err := cc(ctx, v1.PacketRequestHandler(req, resp), opts...); err != nil {
		return nil, err
	}
	return resp, nil
}

func (x clientService) EndpointClose(ctx context.Context, req *v1.EndpointClose, opts ...interface{}) (*emptypb.Empty, error) {
	return EndpointCloseHandler(ctx, x.cc.Request, req, opts...)
}

func EndpointCloseHandler(ctx context.Context, cc Request, req *v1.EndpointClose, opts ...interface{}) (*emptypb.Empty, error) {

	resp := new(emptypb.Empty)
	if err := cc(ctx, v1.PacketRequestHandler(req, nil), opts...); err != nil {
		return nil, err
	}
	return resp, nil
}

func (x clientService) EndpointMessage(ctx context.Context, req *v1.EndpointMessage, opts ...interface{}) (*v1.EndpointMessage, error) {
	return EndpointMessageHandler(ctx, x.cc.Request, req, opts...)
}

func EndpointMessageHandler(ctx context.Context, cc Request, req *v1.EndpointMessage, opts ...interface{}) (*v1.EndpointMessage, error) {

	resp := new(v1.EndpointMessage)
	if err := cc(ctx, v1.PacketRequestHandler(req, resp), opts...); err != nil {
		return nil, err
	}
	return resp, nil
}
