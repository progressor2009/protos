// Code generated by protoc-gen-go-ras. DO NOT EDIT.

// This is a compile-time assertion to ensure that this generated file
// is compatible with the v8platform/protoc-gen-go-ras ras it is being compiled against.

package clientv1

import (
	cast "github.com/spf13/cast"
	codec256 "github.com/v8platform/encoder/ras/codec256"
	v1 "github.com/v8platform/protos/gen/ras/protocol/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	net "net"
	regexp "regexp"
	strings "strings"
	sync "sync"
	time "time"
)

type ClientServiceImpl interface {
	Negotiate(*v1.NegotiateMessage) (*emptypb.Empty, error)
	Connect(*v1.ConnectMessage) (*v1.ConnectMessageAck, error)
	Disconnect(*v1.DisconnectMessage) (*emptypb.Empty, error)
	EndpointOpen(*v1.EndpointOpen) (*v1.EndpointOpenAck, error)
	EndpointClose(*v1.EndpointClose) (*emptypb.Empty, error)
	EndpointMessage(*v1.EndpointMessage) (*v1.EndpointMessage, error)
	NewEndpoint(*v1.EndpointOpenAck) (*v1.Endpoint, error)
}

func NewClientService(host string, opts ...Option) ClientServiceImpl {
	options := &Options{}
	for _, opt := range opts {
		opt(options)
	}
	return &ClientService{
		host:    host,
		Options: options,
		mu:      &sync.Mutex{},
	}
}

// ClientService is the client for RAS service.
type ClientService struct {
	*Options
	host string
	conn net.Conn
	mu   *sync.Mutex
}

var serviceVersions = []string{"3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "9.0", "10.0"}

var re = regexp.MustCompile(`(?m)supported=(.*?)]`)

func (x *ClientService) DetectSupportedVersion(err error) string {

	fail, ok := err.(*v1.EndpointFailureAck)
	if !ok {
		return ""
	}

	if fail.Cause == nil {
		return ""
	}

	matches := re.FindAllString(fail.Cause.Message, -1)

	if len(matches) == 0 {
		return ""
	}

	supported := matches[0]
	for i := len(serviceVersions) - 1; i >= 0; i-- {
		version := serviceVersions[i]
		if strings.Contains(supported, version) {
			return version
		}
	}

	return ""
}

type Option func(*Options)

type Options struct {
	dialer *net.Dialer
}

func WithDialer(dialer *net.Dialer) Option {
	return func(o *Options) { o.dialer = dialer }
}
func (x *ClientService) dial() error {
	if x.conn != nil {
		return nil
	}
	if _, err := net.ResolveTCPAddr("tcp", x.host); err != nil {
		return err
	}

	var err error
	if x.dialer != nil {
		x.conn, err = x.dialer.Dial("tcp", x.host)
		return err
	}
	x.conn, err = net.Dial("tcp", x.host)
	return err
}

func (x *ClientService) Negotiate(req *v1.NegotiateMessage) (*emptypb.Empty, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	// TODO convert to formatter
	if err := req.Formatter(x.conn, 0); err != nil {
		return nil, err
	}
	return new(emptypb.Empty), nil
}
func (x *ClientService) Connect(req *v1.ConnectMessage) (*v1.ConnectMessageAck, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	packet, err := v1.NewPacket(req)
	if err != nil {
		return nil, err
	}
	if _, err := packet.WriteTo(x.conn); err != nil {
		return nil, err
	}
	if err := x.conn.SetReadDeadline(time.Now().Add(5 * time.Second)); err != nil {
		return nil, err
	}
	ackPacket, err := v1.NewPacket(x.conn)
	if err != nil {
		return nil, err
	}
	resp := new(v1.ConnectMessageAck)
	return resp, ackPacket.Unpack(resp)
}

func (x *ClientService) Disconnect(req *v1.DisconnectMessage) (*emptypb.Empty, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	packet, err := v1.NewPacket(req)
	if err != nil {
		return nil, err
	}
	if _, err := packet.WriteTo(x.conn); err != nil {
		return nil, err
	}
	return new(emptypb.Empty), nil
}
func (x *ClientService) EndpointOpen(req *v1.EndpointOpen) (*v1.EndpointOpenAck, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	packet, err := v1.NewPacket(req)
	if err != nil {
		return nil, err
	}
	if _, err := packet.WriteTo(x.conn); err != nil {
		return nil, err
	}
	if err := x.conn.SetReadDeadline(time.Now().Add(5 * time.Second)); err != nil {
		return nil, err
	}
	ackPacket, err := v1.NewPacket(x.conn)
	if err != nil {
		return nil, err
	}
	resp := new(v1.EndpointOpenAck)
	return resp, ackPacket.Unpack(resp)
}

func (x *ClientService) EndpointClose(req *v1.EndpointClose) (*emptypb.Empty, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	packet, err := v1.NewPacket(req)
	if err != nil {
		return nil, err
	}
	if _, err := packet.WriteTo(x.conn); err != nil {
		return nil, err
	}
	return new(emptypb.Empty), nil
}
func (x *ClientService) EndpointMessage(req *v1.EndpointMessage) (*v1.EndpointMessage, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	packet, err := v1.NewPacket(req)
	if err != nil {
		return nil, err
	}
	if _, err := packet.WriteTo(x.conn); err != nil {
		return nil, err
	}
	if err := x.conn.SetReadDeadline(time.Now().Add(5 * time.Second)); err != nil {
		return nil, err
	}
	ackPacket, err := v1.NewPacket(x.conn)
	if err != nil {
		return nil, err
	}
	resp := new(v1.EndpointMessage)
	return resp, ackPacket.Unpack(resp)
}

func (x *ClientService) NewEndpoint(req *v1.EndpointOpenAck) (*v1.Endpoint, error) {
	return &v1.Endpoint{
		Service: req.GetService(),
		Version: cast.ToInt32(cast.ToFloat32(req.GetVersion())),
		Id:      req.GetEndpointId(),
		Format:  codec256.Version(),
	}, nil
}

type EndpointServiceImpl interface {
	Request(req v1.EndpointMessageFormatter, resp v1.EndpointMessageParser) error
}

func NewEndpointService(clientService ClientServiceImpl, endpoint v1.EndpointImpl) EndpointServiceImpl {
	return &EndpointService{
		endpoint,
		clientService,
	}
}

// EndpointService is the endpoint service for RAS service.
type EndpointService struct {
	v1.EndpointImpl
	client ClientServiceImpl
}

func (x *EndpointService) Request(req v1.EndpointMessageFormatter, resp v1.EndpointMessageParser) error {
	reqMessage, err := x.NewMessage(req)
	if err != nil {
		return err
	}
	if respMessage, err := x.client.EndpointMessage(reqMessage); err == nil {
		return x.UnpackMessage(respMessage, resp)
	}
	return err
}
