// Code generated by protoc-gen-go-ras. DO NOT EDIT.

// This is a compile-time assertion to ensure that this generated file
// is compatible with the v8platform/protoc-gen-go-ras ras it is being compiled against.

package clientv1

import (
	context "context"
	v1 "github.com/v8platform/protos/gen/ras/protocol/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	regexp "regexp"
	strings "strings"
)

type ClientService interface {
	Negotiate(ctx context.Context, req *v1.NegotiateMessage, opts ...interface{}) (*emptypb.Empty, error)
	Connect(ctx context.Context, req *v1.ConnectMessage, opts ...interface{}) (*v1.ConnectMessageAck, error)
	Disconnect(ctx context.Context, req *v1.DisconnectMessage, opts ...interface{}) (*emptypb.Empty, error)
	EndpointOpen(ctx context.Context, req *v1.EndpointOpen, opts ...interface{}) (*v1.EndpointOpenAck, error)
	EndpointClose(ctx context.Context, req *v1.EndpointClose, opts ...interface{}) (*emptypb.Empty, error)
	EndpointMessage(ctx context.Context, req *v1.EndpointMessage, opts ...interface{}) (*v1.EndpointMessage, error)
}

type Channel interface {
	SendMsg(ctx context.Context, msg interface{}, opts ...interface{}) error
	RecvMsg(ctx context.Context, msg interface{}, opts ...interface{}) error
}

type Client interface {
	Invoke(ctx context.Context, needEndpoint bool, req interface{}, handler InvokeHandler, opts ...interface{}) (interface{}, error)
}

type InvokeHandler func(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error)
type Interceptor func(ctx context.Context, channel Channel, endpoint Endpoint, info *RequestInfo, req interface{}, handler InterceptorHandler) (interface{}, error)
type InterceptorHandler func(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}) (interface{}, error)

type Endpoint interface {
	GetVersion() int32
	GetId() int32
}

func NewClientService(client Client) ClientService {
	return clientService{
		cc: client,
	}
}

// ClientService is the client for RAS service.
type clientService struct {
	cc Client
}

type RequestInfo struct {
	Method     string
	FullMethod string
}

var serviceVersions = []string{"3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "9.0", "10.0"}

var re = regexp.MustCompile(`(?m)supported=(.*?)]`)

// DetectSupportedVersion func helpers detect supported version in EndpointFailureAck
func DetectSupportedVersion(err error) string {

	fail, ok := err.(*v1.EndpointFailureAck)
	if !ok {
		return ""
	}

	if fail.Cause == nil {
		return ""
	}

	matches := re.FindAllString(fail.Cause.Message, -1)

	if len(matches) == 0 {
		return ""
	}

	supported := matches[0]
	for i := len(serviceVersions) - 1; i >= 0; i-- {
		version := serviceVersions[i]
		if strings.Contains(supported, version) {
			return version
		}
	}

	return ""
}

func (x clientService) Negotiate(ctx context.Context, req *v1.NegotiateMessage, opts ...interface{}) (*emptypb.Empty, error) {
	reply, err := x.cc.Invoke(ctx, false, req, NegotiateHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func NegotiateHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v1.PacketChannelRequest(ctx, channel, req.(*v1.NegotiateMessage), nil)
	}
	info := &RequestInfo{
		Method:     "Negotiate",
		FullMethod: "/ras.client.v1.ClientService/Negotiate",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v1.PacketChannelRequest(ctx, cc, req.(*v1.NegotiateMessage), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x clientService) Connect(ctx context.Context, req *v1.ConnectMessage, opts ...interface{}) (*v1.ConnectMessageAck, error) {
	reply, err := x.cc.Invoke(ctx, false, req, ConnectHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.ConnectMessageAck), nil
}

func ConnectHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.ConnectMessageAck)
		return reply, v1.PacketChannelRequest(ctx, channel, req.(*v1.ConnectMessage), reply)
	}
	info := &RequestInfo{
		Method:     "Connect",
		FullMethod: "/ras.client.v1.ClientService/Connect",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.ConnectMessageAck)
		return reply, v1.PacketChannelRequest(ctx, cc, req.(*v1.ConnectMessage), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x clientService) Disconnect(ctx context.Context, req *v1.DisconnectMessage, opts ...interface{}) (*emptypb.Empty, error) {
	reply, err := x.cc.Invoke(ctx, false, req, DisconnectHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func DisconnectHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v1.PacketChannelRequest(ctx, channel, req.(*v1.DisconnectMessage), nil)
	}
	info := &RequestInfo{
		Method:     "Disconnect",
		FullMethod: "/ras.client.v1.ClientService/Disconnect",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v1.PacketChannelRequest(ctx, cc, req.(*v1.DisconnectMessage), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x clientService) EndpointOpen(ctx context.Context, req *v1.EndpointOpen, opts ...interface{}) (*v1.EndpointOpenAck, error) {
	reply, err := x.cc.Invoke(ctx, false, req, EndpointOpenHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.EndpointOpenAck), nil
}

func EndpointOpenHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.EndpointOpenAck)
		return reply, v1.PacketChannelRequest(ctx, channel, req.(*v1.EndpointOpen), reply)
	}
	info := &RequestInfo{
		Method:     "EndpointOpen",
		FullMethod: "/ras.client.v1.ClientService/EndpointOpen",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.EndpointOpenAck)
		return reply, v1.PacketChannelRequest(ctx, cc, req.(*v1.EndpointOpen), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x clientService) EndpointClose(ctx context.Context, req *v1.EndpointClose, opts ...interface{}) (*emptypb.Empty, error) {
	reply, err := x.cc.Invoke(ctx, false, req, EndpointCloseHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*emptypb.Empty), nil
}

func EndpointCloseHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(emptypb.Empty)
		return reply, v1.PacketChannelRequest(ctx, channel, req.(*v1.EndpointClose), nil)
	}
	info := &RequestInfo{
		Method:     "EndpointClose",
		FullMethod: "/ras.client.v1.ClientService/EndpointClose",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(emptypb.Empty)
		return reply, v1.PacketChannelRequest(ctx, cc, req.(*v1.EndpointClose), nil)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}

func (x clientService) EndpointMessage(ctx context.Context, req *v1.EndpointMessage, opts ...interface{}) (*v1.EndpointMessage, error) {
	reply, err := x.cc.Invoke(ctx, false, req, EndpointMessageHandler, opts...)
	if err != nil {
		return nil, err
	}
	return reply.(*v1.EndpointMessage), nil
}

func EndpointMessageHandler(ctx context.Context, channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {

	if interceptor == nil {
		reply := new(v1.EndpointMessage)
		return reply, v1.PacketChannelRequest(ctx, channel, req.(*v1.EndpointMessage), reply)
	}
	info := &RequestInfo{
		Method:     "EndpointMessage",
		FullMethod: "/ras.client.v1.ClientService/EndpointMessage",
	}

	handler := func(ctx context.Context, cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {
		reply := new(v1.EndpointMessage)
		return reply, v1.PacketChannelRequest(ctx, cc, req.(*v1.EndpointMessage), reply)
	}
	return interceptor(ctx, channel, endpoint, info, req, handler)
}
