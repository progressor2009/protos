// Code generated by protoc-gen-go-ras. DO NOT EDIT.

// This is a compile-time assertion to ensure that this generated file
// is compatible with the v8platform/protoc-gen-go-ras ras it is being compiled against.

package clientv1

import (
	fmt "fmt"
	cast "github.com/spf13/cast"
	codec256 "github.com/v8platform/encoder/ras/codec256"
	v1 "github.com/v8platform/protos/gen/ras/protocol/v1"
	proto "google.golang.org/protobuf/proto"
	anypb "google.golang.org/protobuf/types/known/anypb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	net "net"
	regexp "regexp"
	strings "strings"
	sync "sync"
	time "time"
)

type ClientServiceImpl interface {
	Negotiate(*v1.NegotiateMessage) (*emptypb.Empty, error)
	Connect(*v1.ConnectMessage) (*v1.ConnectMessageAck, error)
	Disconnect(*v1.DisconnectMessage) (*emptypb.Empty, error)
	EndpointOpen(*v1.EndpointOpen) (*v1.EndpointOpenAck, error)
	EndpointClose(*v1.EndpointClose) (*emptypb.Empty, error)
	EndpointMessage(*v1.EndpointMessage) (*v1.EndpointMessage, error)
	NewEndpoint(*v1.EndpointOpenAck) (*v1.Endpoint, error)
	DetectSupportedVersion(err error) string
}

func NewClientService(host string, opts ...ClientServiceOption) ClientServiceImpl {
	options := &ClientServiceOptions{timeout: 5 * time.Second}
	for _, opt := range opts {
		opt(options)
	}
	return &clientService{
		host:                 host,
		ClientServiceOptions: options,
		mu:                   &sync.Mutex{},
	}
}

// ClientService is the client for RAS service.
type clientService struct {
	*ClientServiceOptions
	host string
	conn net.Conn
	mu   *sync.Mutex
}

var serviceVersions = []string{"3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "9.0", "10.0"}

var re = regexp.MustCompile(`(?m)supported=(.*?)]`)

func (x *clientService) DetectSupportedVersion(err error) string {

	fail, ok := err.(*v1.EndpointFailureAck)
	if !ok {
		return ""
	}

	if fail.Cause == nil {
		return ""
	}

	matches := re.FindAllString(fail.Cause.Message, -1)

	if len(matches) == 0 {
		return ""
	}

	supported := matches[0]
	for i := len(serviceVersions) - 1; i >= 0; i-- {
		version := serviceVersions[i]
		if strings.Contains(supported, version) {
			return version
		}
	}

	return ""
}

type ClientServiceOption func(*ClientServiceOptions)

type ClientServiceOptions struct {
	dialer  *net.Dialer
	timeout time.Duration
}

func WithDialer(dialer *net.Dialer) ClientServiceOption {
	return func(o *ClientServiceOptions) { o.dialer = dialer }
}

func SetTimeout(timeout time.Duration) ClientServiceOption {
	return func(o *ClientServiceOptions) { o.timeout = timeout }
}
func (x *clientService) dial() error {
	if x.conn != nil {
		return nil
	}
	if _, err := net.ResolveTCPAddr("tcp", x.host); err != nil {
		return err
	}

	var err error
	if x.dialer != nil {
		x.conn, err = x.dialer.Dial("tcp", x.host)
		return err
	}
	x.conn, err = net.Dial("tcp", x.host)
	return err
}

func (x *clientService) Negotiate(req *v1.NegotiateMessage) (*emptypb.Empty, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	if err := req.Formatter(x.conn, 0); err != nil {
		return nil, err
	}
	return new(emptypb.Empty), nil
}
func (x *clientService) Connect(req *v1.ConnectMessage) (*v1.ConnectMessageAck, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	packet, err := v1.NewPacket(req)
	if err != nil {
		return nil, err
	}
	if _, err := packet.WriteTo(x.conn); err != nil {
		return nil, err
	}
	if err := x.conn.SetReadDeadline(time.Now().Add(x.timeout)); err != nil {
		return nil, err
	}
	ackPacket, err := v1.NewPacket(x.conn)
	if err != nil {
		return nil, err
	}
	resp := new(v1.ConnectMessageAck)
	return resp, ackPacket.Unpack(resp)
}

func (x *clientService) Disconnect(req *v1.DisconnectMessage) (*emptypb.Empty, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	packet, err := v1.NewPacket(req)
	if err != nil {
		return nil, err
	}
	if _, err := packet.WriteTo(x.conn); err != nil {
		return nil, err
	}
	return new(emptypb.Empty), nil
}
func (x *clientService) EndpointOpen(req *v1.EndpointOpen) (*v1.EndpointOpenAck, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	packet, err := v1.NewPacket(req)
	if err != nil {
		return nil, err
	}
	if _, err := packet.WriteTo(x.conn); err != nil {
		return nil, err
	}
	if err := x.conn.SetReadDeadline(time.Now().Add(x.timeout)); err != nil {
		return nil, err
	}
	ackPacket, err := v1.NewPacket(x.conn)
	if err != nil {
		return nil, err
	}
	resp := new(v1.EndpointOpenAck)
	return resp, ackPacket.Unpack(resp)
}

func (x *clientService) EndpointClose(req *v1.EndpointClose) (*emptypb.Empty, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	packet, err := v1.NewPacket(req)
	if err != nil {
		return nil, err
	}
	if _, err := packet.WriteTo(x.conn); err != nil {
		return nil, err
	}
	return new(emptypb.Empty), nil
}
func (x *clientService) EndpointMessage(req *v1.EndpointMessage) (*v1.EndpointMessage, error) {
	if err := x.dial(); err != nil {
		return nil, err
	}
	x.mu.Lock()
	defer x.mu.Unlock()
	packet, err := v1.NewPacket(req)
	if err != nil {
		return nil, err
	}
	if _, err := packet.WriteTo(x.conn); err != nil {
		return nil, err
	}
	if err := x.conn.SetReadDeadline(time.Now().Add(x.timeout)); err != nil {
		return nil, err
	}
	ackPacket, err := v1.NewPacket(x.conn)
	if err != nil {
		return nil, err
	}
	resp := new(v1.EndpointMessage)
	return resp, ackPacket.Unpack(resp)
}

func (x *clientService) NewEndpoint(req *v1.EndpointOpenAck) (*v1.Endpoint, error) {
	return &v1.Endpoint{
		Service: req.GetService(),
		Version: cast.ToInt32(cast.ToFloat32(req.GetVersion())),
		Id:      req.GetEndpointId(),
		Format:  codec256.Version(),
	}, nil
}

type EndpointServiceImpl interface {
	Request(*EndpointRequest) (*anypb.Any, error)
}

func NewEndpointService(clientService ClientServiceImpl, endpoint v1.EndpointImpl) EndpointServiceImpl {
	return &endpointService{
		endpoint,
		clientService,
	}
}

// EndpointService is the endpoint service for RAS service.
type endpointService struct {
	v1.EndpointImpl
	client ClientServiceImpl
}

func (x *endpointService) Request(req *EndpointRequest) (*anypb.Any, error) {
	message, err := anypb.UnmarshalNew(req.GetRequest(), proto.UnmarshalOptions{})
	if err != nil {
		return nil, err
	}

	reqMessage, err := x.NewMessage(message)
	if err != nil {
		return nil, err
	}

	respMessage, err := x.client.EndpointMessage(reqMessage)
	if err != nil {
		return nil, err
	}

	respProtoMessage, err := anypb.UnmarshalNew(req.GetRespond(), proto.UnmarshalOptions{})
	if err != nil {
		return nil, err
	}

	if _, ok := respProtoMessage.(*emptypb.Empty); ok {
		if err := x.UnpackMessage(respMessage, nil); err != nil {
			return nil, err
		}
		return anypb.New(respProtoMessage)
	}

	messageParser, ok := respProtoMessage.(v1.EndpointMessageParser)
	if !ok {
		return nil, fmt.Errorf("not parser interface")
	}
	if err := x.UnpackMessage(respMessage, messageParser); err != nil {
		return nil, err
	}
	return anypb.New(respProtoMessage)
}
