// Code generated by protoc-gen-go-ras. DO NOT EDIT.

// This is a compile-time assertion to ensure that this generated file
// is compatible with the v8platform/protoc-gen-go-ras ras it is being compiled against.

package clientv1

import (
	context "context"
	v1 "github.com/v8platform/protos/gen/ras/messages/v1"
	proto "google.golang.org/protobuf/proto"
	anypb "google.golang.org/protobuf/types/known/anypb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

type InfobasesServiceImpl interface {
	GetShortInfobases(ctx context.Context, req *v1.GetInfobasesRequest) (*v1.GetInfobasesResponse, error)
	CreateInfobase(ctx context.Context, req *v1.CreateInfobaseRequest) (*v1.CreateInfobaseResponse, error)
	DropInfobase(ctx context.Context, req *v1.DropInfobaseRequest) (*emptypb.Empty, error)
	UpdateInfobase(ctx context.Context, req *v1.UpdateInfobaseRequest) (*emptypb.Empty, error)
	UpdateInfobaseSummary(ctx context.Context, req *v1.UpdateInfobaseSummaryRequest) (*emptypb.Empty, error)
}

func NewInfobasesService(endpointService EndpointServiceImpl) InfobasesServiceImpl {
	return &InfobasesService{
		endpointService,
	}
}

// InfobasesService is the endpoint message service for RAS service.
type InfobasesService struct {
	e EndpointServiceImpl
}

func (x *InfobasesService) GetShortInfobases(ctx context.Context, req *v1.GetInfobasesRequest) (*v1.GetInfobasesResponse, error) {

	var resp v1.GetInfobasesResponse

	anyRequest, err := anypb.New(req)
	if err != nil {
		return nil, err
	}

	anyRespond, err := anypb.New(&resp)
	if err != nil {
		return nil, err
	}

	endpointRequest := &EndpointRequest{
		Request: anyRequest,
		Respond: anyRespond,
	}

	response, err := x.e.Request(ctx, endpointRequest)
	if err != nil {
		return nil, err
	}

	if err := anypb.UnmarshalTo(response, &resp, proto.UnmarshalOptions{}); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (x *InfobasesService) CreateInfobase(ctx context.Context, req *v1.CreateInfobaseRequest) (*v1.CreateInfobaseResponse, error) {

	var resp v1.CreateInfobaseResponse

	anyRequest, err := anypb.New(req)
	if err != nil {
		return nil, err
	}

	anyRespond, err := anypb.New(&resp)
	if err != nil {
		return nil, err
	}

	endpointRequest := &EndpointRequest{
		Request: anyRequest,
		Respond: anyRespond,
	}

	response, err := x.e.Request(ctx, endpointRequest)
	if err != nil {
		return nil, err
	}

	if err := anypb.UnmarshalTo(response, &resp, proto.UnmarshalOptions{}); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (x *InfobasesService) DropInfobase(ctx context.Context, req *v1.DropInfobaseRequest) (*emptypb.Empty, error) {

	var resp emptypb.Empty

	anyRequest, err := anypb.New(req)
	if err != nil {
		return nil, err
	}

	anyRespond, err := anypb.New(&resp)
	if err != nil {
		return nil, err
	}

	endpointRequest := &EndpointRequest{
		Request: anyRequest,
		Respond: anyRespond,
	}

	response, err := x.e.Request(ctx, endpointRequest)
	if err != nil {
		return nil, err
	}

	if err := anypb.UnmarshalTo(response, &resp, proto.UnmarshalOptions{}); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (x *InfobasesService) UpdateInfobase(ctx context.Context, req *v1.UpdateInfobaseRequest) (*emptypb.Empty, error) {

	var resp emptypb.Empty

	anyRequest, err := anypb.New(req)
	if err != nil {
		return nil, err
	}

	anyRespond, err := anypb.New(&resp)
	if err != nil {
		return nil, err
	}

	endpointRequest := &EndpointRequest{
		Request: anyRequest,
		Respond: anyRespond,
	}

	response, err := x.e.Request(ctx, endpointRequest)
	if err != nil {
		return nil, err
	}

	if err := anypb.UnmarshalTo(response, &resp, proto.UnmarshalOptions{}); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (x *InfobasesService) UpdateInfobaseSummary(ctx context.Context, req *v1.UpdateInfobaseSummaryRequest) (*emptypb.Empty, error) {

	var resp emptypb.Empty

	anyRequest, err := anypb.New(req)
	if err != nil {
		return nil, err
	}

	anyRespond, err := anypb.New(&resp)
	if err != nil {
		return nil, err
	}

	endpointRequest := &EndpointRequest{
		Request: anyRequest,
		Respond: anyRespond,
	}

	response, err := x.e.Request(ctx, endpointRequest)
	if err != nil {
		return nil, err
	}

	if err := anypb.UnmarshalTo(response, &resp, proto.UnmarshalOptions{}); err != nil {
		return nil, err
	}
	return &resp, nil
}
