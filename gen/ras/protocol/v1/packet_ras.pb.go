// Code generated by github.com/v8platform/protoc-gen-go-ras. DO NOT EDIT.

package protocolv1

import (
	bytes "bytes"
	fmt "fmt"
	codec256 "github.com/v8platform/encoder/ras/codec256"
	io "io"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the v8platform/protoc-gen-go-ras ras it is being compiled against.
// codec256.io.

// Helpers generated by github.com/v8platform/protoc-gen-go-ras. DO NOT EDIT
type PacketMessage interface {
	PacketMessageFormatter
	PacketMessageParser
}

type PacketMessageFormatter interface {
	GetPacketType() PacketType
	Formatter(writer io.Writer, version int32) error
}

type PacketMessageParser interface {
	GetPacketType() PacketType
	Parse(reader io.Reader, version int32) error
}

func NewPacket(message PacketMessageFormatter) (*Packet, error) {
	buf := &bytes.Buffer{}
	if err := message.Formatter(buf, 0); err != nil {
		return nil, err
	}
	var packet Packet
	packet.Type = message.GetPacketType()
	packet.Data = buf.Bytes()
	packet.Size = int32(len(packet.Data))
	return &packet, nil
}

func (x *Packet) Unpack(into PacketMessageParser) error {
	if x.GetType() != into.GetPacketType() {
		return fmt.Errorf("unpack type no equal packet type. Has %s want %s", into.GetPacketType(), x.GetType())
	}
	buf := bytes.NewBuffer(x.Data)
	return into.Parse(buf, 0)
}

func (x *Packet) UnpackNew() (PacketMessage, error) {
	var into PacketMessage
	switch x.GetType() {
	// type PacketType_PACKET_TYPE_NEGOTIATE cast NegotiateMessage
	case PacketType_PACKET_TYPE_NEGOTIATE:
		into = &NegotiateMessage{}
	// type PacketType_PACKET_TYPE_ENDPOINT_OPEN_ACK cast EndpointOpenAck
	case PacketType_PACKET_TYPE_ENDPOINT_OPEN_ACK:
		into = &EndpointOpenAck{}
	// type PacketType_PACKET_TYPE_CONNECT_ACK cast ConnectMessageAck
	case PacketType_PACKET_TYPE_CONNECT_ACK:
		into = &ConnectMessageAck{}
	// type PacketType_PACKET_TYPE_ENDPOINT_OPEN cast EndpointOpen
	case PacketType_PACKET_TYPE_ENDPOINT_OPEN:
		into = &EndpointOpen{}
	// type PacketType_PACKET_TYPE_ENDPOINT_FAILURE cast EndpointFailureAck
	case PacketType_PACKET_TYPE_ENDPOINT_FAILURE:
		into = &EndpointFailureAck{}
	// type PacketType_PACKET_TYPE_DISCONNECT cast DisconnectMessage
	case PacketType_PACKET_TYPE_DISCONNECT:
		into = &DisconnectMessage{}
	// type PacketType_PACKET_TYPE_CONNECT cast ConnectMessage
	case PacketType_PACKET_TYPE_CONNECT:
		into = &ConnectMessage{}
	// type PacketType_PACKET_TYPE_ENDPOINT_MESSAGE cast EndpointMessage
	case PacketType_PACKET_TYPE_ENDPOINT_MESSAGE:
		into = &EndpointMessage{}
	default:
		return nil, fmt.Errorf("unknown unpack type %s", x.GetType())
	}
	buf := bytes.NewBuffer(x.Data)
	if err := into.Parse(buf, 0); err != nil {
		return nil, err
	}
	return into, nil
}

func (x *Packet) Parse(reader io.Reader, version int32) error {
	if x == nil {
		return nil
	}
	// decode x.Type opts: encoder:"byte"  order:1
	var val_Type int32
	if err := codec256.ParseByte(reader, &val_Type); err != nil {
		return err
	}
	x.Type = PacketType(val_Type)
	// decode x.Size opts: encoder:"size"  order:2
	if err := codec256.ParseSize(reader, &x.Size); err != nil {
		return err
	}
	// decode x.Data opts: encoder:"bytes"  order:3  type_field:1  size_field:2
	x.Data = make([]byte, x.GetSize())
	if err := codec256.ParseBytes(reader, x.Data); err != nil {
		return err
	}
	return nil
}
func (x *Packet) Formatter(writer io.Writer, version int32) error {
	if x == nil {
		return nil
	}
	// decode x.Type opts: encoder:"byte"  order:1
	if err := codec256.FormatByte(writer, int32(x.Type)); err != nil {
		return err
	}
	// decode x.Size opts: encoder:"size"  order:2
	if err := codec256.FormatSize(writer, x.Size); err != nil {
		return err
	}
	// decode x.Data opts: encoder:"bytes"  order:3  type_field:1  size_field:2
	if err := codec256.FormatBytes(writer, x.Data); err != nil {
		return err
	}
	return nil
}
