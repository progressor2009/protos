// Code generated by protoc-gen-go-ras. DO NOT EDIT.

// This is a compile-time assertion to ensure that this generated file
// is compatible with the v8platform/protoc-gen-go-ras ras it is being compiled against.

package serializev1

import (
	codec256 "github.com/v8platform/encoder/ras/codec256"
	io "io"
)

func (x *ServerInfo) Parse(reader io.Reader, version int32) error {
	if x == nil {
		return nil
	}
	// decode x.Uuid opts: encoder:"uuid" order:1
	if err := codec256.ParseUUID(reader, &x.Uuid); err != nil {
		return err
	}
	// decode x.AgentHost opts: order:2
	if err := codec256.ParseString(reader, &x.AgentHost); err != nil {
		return err
	}
	// decode x.AgentPort opts: encoder:"short" order:3
	if err := codec256.ParseShort(reader, &x.AgentPort); err != nil {
		return err
	}
	// decode x.Name opts: order:4
	if err := codec256.ParseString(reader, &x.Name); err != nil {
		return err
	}
	// decode x.MainServer opts: order:5
	if err := codec256.ParseBool(reader, &x.MainServer); err != nil {
		return err
	}
	// decode x.SafeWorkingProcessesMemoryLimit opts: encoder:"long" order:6
	if err := codec256.ParseLong(reader, &x.SafeWorkingProcessesMemoryLimit); err != nil {
		return err
	}
	// decode x.SafeCallMemoryLimit opts: order:7
	if err := codec256.ParseLong(reader, &x.SafeCallMemoryLimit); err != nil {
		return err
	}
	// decode x.InfobasesLimit opts: order:8
	if err := codec256.ParseInt(reader, &x.InfobasesLimit); err != nil {
		return err
	}
	// decode x.MemoryLimit opts: order:9
	if err := codec256.ParseLong(reader, &x.MemoryLimit); err != nil {
		return err
	}
	// decode x.ConnectionsLimit opts: order:10
	if err := codec256.ParseInt(reader, &x.ConnectionsLimit); err != nil {
		return err
	}
	// decode x.ClusterPort opts: encoder:"short" order:11
	if err := codec256.ParseShort(reader, &x.ClusterPort); err != nil {
		return err
	}
	// decode x.DedicateManagers opts: order:12
	if err := codec256.ParseBool(reader, &x.DedicateManagers); err != nil {
		return err
	}
	// decode x.PortRanges opts: order:13
	var size_PortRanges int
	if err := codec256.ParseSize(reader, &size_PortRanges); err != nil {
		return err
	}
	for i := 0; i < size_PortRanges; i++ {
		val := &PortRange{}
		if err := val.Parse(reader, version); err != nil {
			return err
		}

		x.PortRanges = append(x.PortRanges, val)
	}
	if version >= 8 {
		// decode x.CriticalTotalMemory opts: order:14 version:8
		if err := codec256.ParseLong(reader, &x.CriticalTotalMemory); err != nil {
			return err
		}
		// decode x.TemporaryAllowedTotalMemory opts: order:15 version:8
		if err := codec256.ParseLong(reader, &x.TemporaryAllowedTotalMemory); err != nil {
			return err
		}
		// decode x.TemporaryAllowedTotalMemoryTimeLimit opts: order:16 version:8
		if err := codec256.ParseLong(reader, &x.TemporaryAllowedTotalMemoryTimeLimit); err != nil {
			return err
		}
	}
	return nil
}
func (x *ServerInfo) Formatter(writer io.Writer, version int32) error {
	if x == nil {
		return nil
	}
	// decode x.Uuid opts: encoder:"uuid" order:1
	if err := codec256.FormatUuid(writer, x.Uuid); err != nil {
		return err
	}
	// decode x.AgentHost opts: order:2
	if err := codec256.FormatString(writer, x.AgentHost); err != nil {
		return err
	}
	// decode x.AgentPort opts: encoder:"short" order:3
	if err := codec256.FormatShort(writer, x.AgentPort); err != nil {
		return err
	}
	// decode x.Name opts: order:4
	if err := codec256.FormatString(writer, x.Name); err != nil {
		return err
	}
	// decode x.MainServer opts: order:5
	if err := codec256.FormatBool(writer, x.MainServer); err != nil {
		return err
	}
	// decode x.SafeWorkingProcessesMemoryLimit opts: encoder:"long" order:6
	if err := codec256.FormatLong(writer, x.SafeWorkingProcessesMemoryLimit); err != nil {
		return err
	}
	// decode x.SafeCallMemoryLimit opts: order:7
	if err := codec256.FormatLong(writer, x.SafeCallMemoryLimit); err != nil {
		return err
	}
	// decode x.InfobasesLimit opts: order:8
	if err := codec256.FormatInt(writer, x.InfobasesLimit); err != nil {
		return err
	}
	// decode x.MemoryLimit opts: order:9
	if err := codec256.FormatLong(writer, x.MemoryLimit); err != nil {
		return err
	}
	// decode x.ConnectionsLimit opts: order:10
	if err := codec256.FormatInt(writer, x.ConnectionsLimit); err != nil {
		return err
	}
	// decode x.ClusterPort opts: encoder:"short" order:11
	if err := codec256.FormatShort(writer, x.ClusterPort); err != nil {
		return err
	}
	// decode x.DedicateManagers opts: order:12
	if err := codec256.FormatBool(writer, x.DedicateManagers); err != nil {
		return err
	}
	// decode x.PortRanges opts: order:13
	if err := codec256.FormatSize(writer, len(x.PortRanges)); err != nil {
		return err
	}
	for i := 0; i < len(x.PortRanges); i++ {
		if err := x.PortRanges[i].Formatter(writer, version); err != nil {
			return err
		}
	}
	if version >= 8 {
		// decode x.CriticalTotalMemory opts: order:14 version:8
		if err := codec256.FormatLong(writer, x.CriticalTotalMemory); err != nil {
			return err
		}
		// decode x.TemporaryAllowedTotalMemory opts: order:15 version:8
		if err := codec256.FormatLong(writer, x.TemporaryAllowedTotalMemory); err != nil {
			return err
		}
		// decode x.TemporaryAllowedTotalMemoryTimeLimit opts: order:16 version:8
		if err := codec256.FormatLong(writer, x.TemporaryAllowedTotalMemoryTimeLimit); err != nil {
			return err
		}
	}
	return nil
}
func (x *PortRange) Parse(reader io.Reader, version int32) error {
	if x == nil {
		return nil
	}
	// decode x.High opts: encoder:"short" order:1
	if err := codec256.ParseShort(reader, &x.High); err != nil {
		return err
	}
	// decode x.Low opts: encoder:"short" order:2
	if err := codec256.ParseShort(reader, &x.Low); err != nil {
		return err
	}
	return nil
}
func (x *PortRange) Formatter(writer io.Writer, version int32) error {
	if x == nil {
		return nil
	}
	// decode x.High opts: encoder:"short" order:1
	if err := codec256.FormatShort(writer, x.High); err != nil {
		return err
	}
	// decode x.Low opts: encoder:"short" order:2
	if err := codec256.FormatShort(writer, x.Low); err != nil {
		return err
	}
	return nil
}
